<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üéÑ Âú£ËØûÊ†ë üéÑ</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      margin: 0;
      height: 100vh;
      overflow: hidden;
      background: #050505;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #c5a880;
    }

    #three-canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #start-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      z-index: 999;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      transition: opacity 1s ease;
    }

    .modal-content {
      background: linear-gradient(145deg, #1a1a1a, #2a2a2a);
      padding: 40px;
      border-radius: 20px;
      border: 2px solid #c5a880;
      box-shadow: 0 0 30px rgba(197, 168, 128, 0.3);
      text-align: center;
      max-width: 90%;
      width: 400px;
    }

    .modal-title {
      font-size: 2rem;
      color: #c5a880;
      margin-bottom: 20px;
      font-weight: bold;
    }

    .modal-text {
      font-size: 1.1rem;
      color: #ccc;
      margin-bottom: 30px;
    }

    .btn-group {
      display: flex;
      justify-content: space-around;
      gap: 20px;
      position: relative;
    }

    .btn {
      padding: 12px 30px;
      border: none;
      border-radius: 50px;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: bold;
      outline: none;
    }

    .btn-accept {
      background: linear-gradient(45deg, #d4af37, #c5a880);
      color: #000;
      box-shadow: 0 0 15px rgba(212, 175, 55, 0.5);
    }

    .btn-accept:hover {
      transform: scale(1.05);
      box-shadow: 0 0 25px rgba(212, 175, 55, 0.8);
    }

    .btn-reject {
      background: #333;
      color: #888;
      border: 1px solid #555;
    }

    #christmas-text {
      position: absolute;
      top: 10%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Brush Script MT', cursive;
      font-size: 4rem;
      background: linear-gradient(to bottom, #fff, #c5a880);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 20px rgba(197, 168, 128, 0.5);
      z-index: 10;
      opacity: 0;
      pointer-events: none;
      text-align: center;
      width: 100%;
    }

    .fade-in {
      animation: fadeInText 3s forwards ease-in-out;
      animation-delay: 1s;
    }

    @keyframes fadeInText {
      0% { opacity: 0; transform: translate(-50%, -30%); }
      100% { opacity: 1; transform: translate(-50%, -50%); }
    }

    .loading {
      color: white;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 100;
    }

    @media (max-width: 600px) {
      .modal-content { width: 90%; padding: 20px; }
      .modal-title { font-size: 1.5rem; }
      #christmas-text { font-size: 2.5rem; top: 10%; }
    }
  </style>
</head>

<body>
  <div class="loading">Âä†ËΩΩ‰∏≠...</div>
  <canvas id="three-canvas"></canvas>
  <div id="start-modal">
    <div class="modal-content">
      <div class="modal-title">üéÅ Âú£ËØûÁ§ºÁâ©</div>
      <p class="modal-text">ÂèÆÂíöÔºÅ‰Ω†Êúâ‰∏Ä‰ªΩÊù•Ëá™Âú£ËØûËÄÅ‰∫∫ÁöÑ‰∏ìÂ±ûÁ§ºÁâ©ÔºåÊòØÂê¶Êü•Êî∂Ôºü</p>
      <div class="btn-group" id="btn-container">
        <button class="btn btn-reject" id="btn-no">ÊÆãÂøçÊãíÁªù</button>
        <button class="btn btn-accept" id="btn-yes">ÂºÄÂøÉÊî∂‰∏ã</button>
      </div>
    </div>
  </div>

  <div id="christmas-text">Merry Christmas</div>
  <audio id="christmas-music" loop>
    <source src="https://files.freemusicarchive.org/storage-freemusicarchive-org/music/no_curator/Dott/This_Christmas/Dott_-_01_-_This_Christmas.mp3" type="audio/mpeg">
    ÊÇ®ÁöÑÊµèËßàÂô®‰∏çÊîØÊåÅÈü≥È¢ëÂÖÉÁ¥†„ÄÇ
  </audio>

  <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

  <script>
    let threeRenderer, threeScene, threeCamera, composer;
    const uniforms = {
      time: { type: "f", value: 0.0 },
      step: { type: "f", value: 0.0 },
      flash: { type: "f", value: 0.0 },
      tAudioData: { value: new THREE.DataTexture(new Uint8Array(128), 64, 1, THREE.LuminanceFormat) }
    };

    const params = {
      exposure: 1,
      bloomStrength: 1.8,
      bloomThreshold: 0,
      bloomRadius: 0.6
    };

    function init() {
      initThreeJS();
      document.querySelector('.loading').style.display = 'none';
    }

    function initThreeJS() {
      const canvas = document.getElementById('three-canvas');

      threeScene = new THREE.Scene();
      threeScene.fog = new THREE.FogExp2(0x050505, 0.002);

      threeRenderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
        alpha: true
      });
      threeRenderer.setPixelRatio(window.devicePixelRatio);
      threeRenderer.setSize(window.innerWidth, window.innerHeight);
      threeRenderer.toneMapping = THREE.ReinhardToneMapping;
      threeRenderer.outputEncoding = THREE.sRGBEncoding;
      threeCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
      threeCamera.position.set(-0.1, -2.5, 25);
      threeCamera.rotation.set(0.1, 0, 0);
      addPlane(threeScene, uniforms, 3000);
      addSnow(threeScene, uniforms);

      for (let i = 0; i < 5; i++) {
        addTree(threeScene, uniforms, 4000, [0, 0, -20 * i]);
      }

      const renderScene = new THREE.RenderPass(threeScene, threeCamera);
      const bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.5, 0.4, 0.85
      );
      bloomPass.threshold = params.bloomThreshold;
      bloomPass.strength = params.bloomStrength;
      bloomPass.radius = params.bloomRadius;

      composer = new THREE.EffectComposer(threeRenderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);
      animateThreeJS();
    }

    let step = 0;
    let lastTime = 0;
    let flashState = 0;
    let flashIntensity = 0;
    let flashStartTime = 0;
    const flashDuration = 3000;
    const TAU = 2 * Math.PI;

    function animateThreeJS(currentTime = 0) {
      if (!threeRenderer) return;
      uniforms.time.value = currentTime;
      uniforms.step.value = step;
      flashIntensity = calculateNaturalFlash(currentTime);
      uniforms.flash.value = flashIntensity;
      const bloomPass = composer.passes[1];
      bloomPass.strength = params.bloomStrength * (0.8 + flashIntensity * 0.4);
      step = (step + 1) % 1000;
      composer.render();
      requestAnimationFrame(animateThreeJS);
    }

    function calculateNaturalFlash(currentTime) {
      if (flashStartTime === 0 || currentTime - flashStartTime > flashDuration) {
        if (Math.random() > 0.5 || flashStartTime === 0) {
          flashState = flashState === 0 ? 1 : 0;
          flashStartTime = currentTime;
        }
      }

      const progress = Math.min((currentTime - flashStartTime) / (flashDuration / 2), 1);

      if (flashState === 0) {
        return 1 - progress * progress;
      } else {
        return progress * progress;
      }
    }

    function addTree(scene, uniforms, totalPoints, treePosition) {
      const vertexShader = `
      attribute float mIndex;
      varying vec3 vColor;
      varying float opacity;
      uniform sampler2D tAudioData;
      uniform float flash;
      float norm(float value, float min, float max ){
       return (value - min) / (max - min);
      }
      float lerp(float norm, float min, float max){
       return (max - min) * norm + min;
      }
      float map(float value, float sourceMin, float sourceMax, float destMin, float destMax){
       return lerp(norm(value, sourceMin, sourceMax), destMin, destMax);
      }
      void main() {
       vColor = color;
       vec3 p = position;
       vec4 mvPosition = modelViewMatrix * vec4( p, 1.0 );
       float baseSize = 1.0;
       float sizeMultiplier = mix(0.8, 1.2, flash);
       float sizeMapped = baseSize * sizeMultiplier;
       opacity = map(mvPosition.z , -200.0, 15.0, 0.0, 1.0);
       gl_PointSize = sizeMapped * ( 100.0 / -mvPosition.z );
       gl_Position = projectionMatrix * mvPosition;
      }
      `;
      const fragmentShader = `
      varying vec3 vColor;
      varying float opacity;
      uniform sampler2D pointTexture;
      uniform float flash;
      void main() {
       float brightness = mix(0.7, 1.3, flash);
       vec3 color = vColor * brightness;

       float dist = length(gl_PointCoord.xy - 0.5);
       float glow = smoothstep(0.5, 0.4, dist) * 0.3;

       gl_FragColor = vec4( color + glow, opacity );
       gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
      }
      `;
      const shaderMaterial = new THREE.ShaderMaterial({
        uniforms: {
          ...uniforms,
          pointTexture: {
            value: new THREE.TextureLoader().load(`https://assets.codepen.io/3685267/spark1.png`)
          }
        },
        vertexShader,
        fragmentShader,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        transparent: true,
        vertexColors: true
      });

      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const colors = [];
      const sizes = [];
      const phases = [];
      const mIndexs = [];
      const color = new THREE.Color();

      for (let i = 0; i < totalPoints; i++) {
        const t = Math.random();
        const y = map(t, 0, 1, -8, 10);
        const ang = map(t, 0, 1, 0, 6 * TAU) + TAU / 2 * (i % 2);
        const [z, x] = polar(ang, map(t, 0, 1, 5, 0));
        const modifier = map(t, 0, 1, 1, 0);
        positions.push(x + rand(-0.3 * modifier, 0.3 * modifier));
        positions.push(y + rand(-0.3 * modifier, 0.3 * modifier));
        positions.push(z + rand(-0.3 * modifier, 0.3 * modifier));

        const colorSeed = Math.random();
        if (colorSeed > 0.8) {
            color.setHex(0xff0000);
        } else if (colorSeed > 0.5) {
            color.setHex(0x00ff00);
        } else {
            color.setHSL(map(i, 0, totalPoints, 0.1, 0.2), 1.0, 0.6);
        }

        colors.push(color.r, color.g, color.b);
        phases.push(rand(1000));
        sizes.push(1);
        const mIndex = map(i, 0, totalPoints, 1.0, 0.0);
        mIndexs.push(mIndex);
      }

      geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage));
      geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
      geometry.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));
      geometry.setAttribute("phase", new THREE.Float32BufferAttribute(phases, 1));
      geometry.setAttribute("mIndex", new THREE.Float32BufferAttribute(mIndexs, 1));

      const tree = new THREE.Points(geometry, shaderMaterial);
      const [px, py, pz] = treePosition;
      tree.position.set(px, py, pz);
      scene.add(tree);
    }

    function addSnow(scene, uniforms) {
      const vertexShader = `
      attribute float size;
      attribute float phase;
      attribute float phaseSecondary;
      varying vec3 vColor;
      varying float opacity;
      uniform float time;
      uniform float step;
      float norm(float value, float min, float max ){ return (value - min) / (max - min); }
      float lerp(float norm, float min, float max){ return (max - min) * norm + min; }
      float map(float value, float sourceMin, float sourceMax, float destMin, float destMax){ return lerp(norm(value, sourceMin, sourceMax), destMin, destMax); }
      void main() {
       float t = time* 0.0006;
       vColor = color;
       vec3 p = position;
       p.y = map(mod(phase+step, 1000.0), 0.0, 1000.0, 25.0, -8.0);
       p.x += sin(t+phase);
       p.z += sin(t+phaseSecondary);
       opacity = map(p.z, -150.0, 15.0, 0.0, 1.0);
       vec4 mvPosition = modelViewMatrix * vec4( p, 1.0 );
       gl_PointSize = size * ( 100.0 / -mvPosition.z );
       gl_Position = projectionMatrix * mvPosition;
      }
      `;

      const fragmentShader = `
      uniform sampler2D pointTexture;
      varying vec3 vColor;
      varying float opacity;
      void main() {
       gl_FragColor = vec4( vColor, opacity );
       gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
      }
      `;

      function createSnowSet(sprite) {
        const totalPoints = 300;
        const shaderMaterial = new THREE.ShaderMaterial({
          uniforms: {
            ...uniforms,
            pointTexture: { value: new THREE.TextureLoader().load(sprite) }
          },
          vertexShader,
          fragmentShader,
          blending: THREE.AdditiveBlending,
          depthTest: false,
          transparent: true,
          vertexColors: true
        });

        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const sizes = [];
        const phases = [];
        const phaseSecondaries = [];
        const color = new THREE.Color();

        for (let i = 0; i < totalPoints; i++) {
          const [x, y, z] = [rand(25, -25), 0, rand(15, -150)];
          positions.push(x, y, z);
          color.setHSL(0.6, 0.1, 0.9);
          colors.push(color.r, color.g, color.b);
          phases.push(rand(1000));
          phaseSecondaries.push(rand(1000));
          sizes.push(rand(4, 2));
        }

        geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));
        geometry.setAttribute("phase", new THREE.Float32BufferAttribute(phases, 1));
        geometry.setAttribute("phaseSecondary", new THREE.Float32BufferAttribute(phaseSecondaries, 1));

        const mesh = new THREE.Points(geometry, shaderMaterial);
        scene.add(mesh);
      }

      const snowSprites = [
        "https://assets.codepen.io/3685267/snowflake1.png",
        "https://assets.codepen.io/3685267/snowflake2.png",
        "https://assets.codepen.io/3685267/snowflake3.png",
        "https://assets.codepen.io/3685267/snowflake4.png",
        "https://assets.codepen.io/3685267/snowflake5.png"
      ];

      snowSprites.forEach(sprite => {
        createSnowSet(sprite);
      });
    }

    function addPlane(scene, uniforms, totalPoints) {
      const vertexShader = `
      attribute float size;
      attribute vec3 customColor;
      varying vec3 vColor;
      uniform float flash;
      void main() {
       vColor = customColor * mix(0.95, 1.05, flash - 0.9);
       vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
       gl_PointSize = size * ( 300.0 / -mvPosition.z );
       gl_Position = projectionMatrix * mvPosition;
      }
      `;

      const fragmentShader = `
      varying vec3 vColor;
      void main() {
        float dist = length(gl_PointCoord.xy - 0.5);
        float alpha = 1.0 - smoothstep(0.4, 0.5, dist);
        float glow = smoothstep(0.5, 0.0, dist) * 0.2;
        gl_FragColor = vec4(vColor + glow, alpha * 0.8);
      }
      `;

      const shaderMaterial = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader,
        fragmentShader,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        transparent: true,
        vertexColors: true
      });

      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const colors = [];
      const sizes = [];

      const color = new THREE.Color();

      for (let i = 0; i < totalPoints; i++) {
        const [x, y, z] = [rand(-50, 50), 0, rand(-150, 15)];
        positions.push(x);
        positions.push(y);
        positions.push(z);

        color.setHSL(map(i, 0, totalPoints, 0.5, 0.7), 0.9, 0.4);
        colors.push(color.r, color.g, color.b);
        sizes.push(1.5);
      }

      geometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(positions, 3).setUsage(
          THREE.DynamicDrawUsage));

      geometry.setAttribute(
        "customColor",
        new THREE.Float32BufferAttribute(colors, 3));

      geometry.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));

      const plane = new THREE.Points(geometry, shaderMaterial);
      plane.position.y = -8;
      scene.add(plane);
    }

    const map = (value, sMin, sMax, dMin, dMax) => {
      return dMin + (value - sMin) / (sMax - sMin) * (dMax - dMin);
    };

    const rand = (max, min = 0) => min + Math.random() * (max - min);
    const randInt = (max, min = 0) => Math.floor(min + Math.random() * (max - min));
    const polar = (ang, r = 1) => [r * Math.cos(ang), r * Math.sin(ang)];
    const modal = document.getElementById('start-modal');
    const btnYes = document.getElementById('btn-yes');
    const btnNo = document.getElementById('btn-no');
    const textOverlay = document.getElementById('christmas-text');
    const christmasMusic = document.getElementById('christmas-music');

    btnNo.addEventListener('mouseenter', moveButton);
    btnNo.addEventListener('click', () => {
        alert("È™ó‰Ω†ÁöÑÔºåÂÖ∂ÂÆûÁÇπ‰∫Ü‰πüÊ≤°Áî®ÔºÅüéÑüéÑüéÑ");
    });

    function moveButton() {
        if(window.innerWidth < 768) return;
        const x = Math.random() * 100 - 50;
        const y = Math.random() * 100 - 50;
        btnNo.style.transform = `translate(${x}px, ${y}px)`;
    }

    btnYes.addEventListener('click', () => {
        modal.style.opacity = '0';
        christmasMusic.play().catch(e => console.log("Ëá™Âä®Êí≠ÊîæË¢´ÈòªÊ≠¢:", e));

        setTimeout(() => {
            modal.style.display = 'none';
            textOverlay.classList.add('fade-in');
        }, 1000);
    });

    window.addEventListener('resize', () => {
      if (threeCamera) {
        threeCamera.aspect = window.innerWidth / window.innerHeight;
        threeCamera.updateProjectionMatrix();
        threeRenderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      }
    });

    window.addEventListener('load', init);
  </script>
</body>
</html>
</html>
